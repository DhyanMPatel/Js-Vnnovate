# ðŸŽ“ Interview Questions & Answers

## 1. Beginner Level Questions (0-2 years experience)

### Q1. What is Nodemailer and why would you use it?

**Answer:**
Nodemailer is a Node.js library for sending emails from applications. It abstracts the complexity of SMTP protocol and provides a simple, unified API for sending emails through various providers.

**Key points:**
- Simplifies email sending in Node.js applications
- Supports multiple providers (Gmail, Outlook, SES, SendGrid, etc.)
- Handles SMTP protocol complexity automatically
- Provides features like attachments, HTML content, templates
- Free and open-source

**Use cases:**
- User registration emails
- Password reset notifications
- Order confirmations
- Marketing campaigns

### Q2. How do you send a basic email with Nodemailer?

**Answer:**
```js
const nodemailer = require('nodemailer');

// 1. Create transporter
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: 'your-email@gmail.com',
    pass: 'your-app-password'
  }
});

// 2. Send email
async function sendEmail() {
  const info = await transporter.sendMail({
    from: 'sender@example.com',
    to: 'recipient@example.com',
    subject: 'Hello World',
    text: 'This is a plain text email',
    html: '<h1>This is an HTML email</h1>'
  });
  
  console.log('Email sent:', info.messageId);
}
```

**Key concepts:**
- Transporter: The email delivery mechanism
- Authentication: Using app passwords or OAuth2
- Message structure: from, to, subject, content

### Q3. What's the difference between SMTP and API-based email services?

**Answer:**

**SMTP (Simple Mail Transfer Protocol):**
- Direct protocol for sending emails
- Universal standard supported by all email providers
- More control but requires handling protocol details
- Can be blocked by ISPs/firewalls
- Free but limited by provider restrictions

**API-based services (SendGrid, Mailgun, AWS SES):**
- HTTP API calls to send emails
- Easier integration with modern applications
- Built-in analytics and deliverability features
- Better scalability and reliability
- Usually paid services

**When to use each:**
- SMTP: Low volume, full control needed, budget constraints
- API: High volume, need analytics, better deliverability

### Q4. How do you handle email attachments in Nodemailer?

**Answer:**
```js
const mailOptions = {
  from: 'sender@example.com',
  to: 'recipient@example.com',
  subject: 'Email with attachments',
  html: '<h1>Please find attached files</h1>',
  
  attachments: [
    // File from disk
    {
      filename: 'document.pdf',
      path: '/path/to/document.pdf'
    },
    
    // Buffer content
    {
      filename: 'data.json',
      content: Buffer.from(JSON.stringify({ data: 'example' })),
      contentType: 'application/json'
    },
    
    // Stream attachment
    {
      filename: 'image.png',
      content: fs.createReadStream('/path/to/image.png')
    },
    
    // Inline image with CID
    {
      filename: 'logo.png',
      path: '/path/to/logo.png',
      cid: 'logo@example.com' // Reference in HTML as <img src="cid:logo@example.com">
    }
  ]
};

await transporter.sendMail(mailOptions);
```

**Key points:**
- Attachments array in mail options
- Different types: file path, buffer, stream
- CID for inline images
- Content type specification

### Q5. What are app passwords and why are they needed?

**Answer:**
App passwords are 16-digit passwords generated by email providers (like Gmail) for applications that don't support two-factor authentication directly.

**Why needed:**
- Gmail requires 2FA for security
- Many applications can't handle 2FA prompts
- App passwords provide secure alternative
- Can be revoked individually if compromised

**How to use:**
```js
const transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: 'your-email@gmail.com',
    pass: 'abcd efgh ijkl mnop' // 16-character app password
  }
});
```

---

## 2. Mid-Level Questions (2-4 years experience)

### Q6. How would you implement OAuth2 authentication for Gmail?

**Answer:**
OAuth2 is more secure than app passwords as it uses tokens instead of static passwords.

```js
const { google } = require('googleapis');

class OAuth2EmailService {
  constructor() {
    this.oauth2Client = new google.auth.OAuth2(
      process.env.GMAIL_CLIENT_ID,
      process.env.GMAIL_CLIENT_SECRET,
      process.env.GMAIL_REDIRECT_URI
    );
    
    this.oauth2Client.setCredentials({
      refresh_token: process.env.GMAIL_REFRESH_TOKEN
    });
  }

  async getTransporter() {
    const { token } = await this.oauth2Client.getAccessToken();
    
    return nodemailer.createTransport({
      service: 'gmail',
      auth: {
        type: 'OAuth2',
        user: process.env.GMAIL_USER,
        clientId: process.env.GMAIL_CLIENT_ID,
        clientSecret: process.env.GMAIL_CLIENT_SECRET,
        refreshToken: process.env.GMAIL_REFRESH_TOKEN,
        accessToken: token
      }
    });
  }

  async sendEmail(mailOptions) {
    const transporter = await this.getTransporter();
    return await transporter.sendMail(mailOptions);
  }
}
```

**OAuth2 Flow:**
1. User consents to application access
2. Get authorization code
3. Exchange code for access and refresh tokens
4. Use refresh token for long-term access
5. Access tokens expire and need refreshing

**Benefits:**
- No long-lived passwords in code
- Token-based with expiration
- Granular permissions
- Revocable access

### Q7. How would you handle email sending failures and implement retry logic?

**Answer:**
Implement exponential backoff with proper error classification:

```js
class EmailRetryService {
  constructor() {
    this.maxRetries = 3;
    this.baseDelay = 1000; // 1 second
    this.maxDelay = 30000; // 30 seconds
  }

  async sendEmailWithRetry(mailOptions) {
    let lastError;
    
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        const result = await this.transporter.sendMail(mailOptions);
        
        if (attempt > 1) {
          console.log(`Email sent after ${attempt} attempts`);
        }
        
        return result;
        
      } catch (error) {
        lastError = error;
        
        // Don't retry certain errors
        if (this.isNonRetryableError(error)) {
          throw error;
        }
        
        // Wait before retrying
        if (attempt < this.maxRetries) {
          const delay = this.calculateDelay(attempt);
          await this.sleep(delay);
        }
      }
    }
    
    throw new Error(`Failed after ${this.maxRetries} attempts: ${lastError.message}`);
  }

  isNonRetryableError(error) {
    const nonRetryableCodes = ['EAUTH', 'EENVELOPE', 'EMESSAGE'];
    return nonRetryableCodes.includes(error.code) ||
           error.message.includes('Invalid address');
  }

  calculateDelay(attempt) {
    // Exponential backoff with jitter
    const delay = this.baseDelay * Math.pow(2, attempt - 1);
    const jitter = Math.random() * 1000;
    return Math.min(delay + jitter, this.maxDelay);
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

**Key concepts:**
- Exponential backoff prevents overwhelming servers
- Error classification (retryable vs non-retryable)
- Jitter prevents thundering herd
- Maximum retry limits

### Q8. How would you implement email templates with Nodemailer?

**Answer:**
Use template engines like Handlebars for dynamic content:

```js
const Handlebars = require('handlebars');
const fs = require('fs').promises;

class TemplateEmailService {
  constructor() {
    this.templates = new Map();
    this.transporter = nodemailer.createTransport(/* config */);
  }

  async loadTemplates() {
    const templateDir = './templates';
    const files = await fs.readdir(templateDir);
    
    for (const file of files) {
      if (file.endsWith('.hbs')) {
        const name = file.replace('.hbs', '');
        const content = await fs.readFile(`${templateDir}/${file}`, 'utf8');
        this.templates.set(name, Handlebars.compile(content));
      }
    }
  }

  async sendTemplatedEmail(templateName, to, data) {
    const template = this.templates.get(templateName);
    if (!template) {
      throw new Error(`Template ${templateName} not found`);
    }
    
    const html = template(data);
    const text = this.htmlToText(html);
    
    const mailOptions = {
      from: 'noreply@example.com',
      to: to,
      subject: data.subject,
      html: html,
      text: text
    };
    
    return await this.transporter.sendMail(mailOptions);
  }

  htmlToText(html) {
    return html.replace(/<[^>]*>/g, '').replace(/\s+/g, ' ').trim();
  }
}

// Template example (welcome.hbs)
// <h1>Welcome {{firstName}}!</h1>
// <p>Thank you for joining {{companyName}}.</p>
```

**Benefits:**
- Separation of content and code
- Reusable templates
- Dynamic content insertion
- Consistent branding

### Q9. How would you implement rate limiting for email sending?

**Answer:**
Implement rate limiting to prevent abuse and provider restrictions:

```js
class RateLimitedEmailService {
  constructor() {
    this.transporter = nodemailer.createTransport(/* config */);
    this.limits = {
      gmail: { emails: 100, window: 60000 }, // 100 emails per minute
      sendgrid: { emails: 1000, window: 60000 } // 1000 emails per minute
    };
    this.sentEmails = new Map();
  }

  async sendEmailWithRateLimit(mailOptions, provider = 'gmail') {
    const limit = this.limits[provider];
    const key = `${provider}_${Date.now()}`;
    
    // Check rate limit
    if (this.isRateLimited(provider, limit)) {
      const waitTime = this.calculateWaitTime(provider, limit);
      throw new Error(`Rate limit exceeded. Wait ${waitTime}ms`);
    }
    
    // Send email
    const result = await this.transporter.sendMail(mailOptions);
    
    // Record sent email
    this.recordSentEmail(provider);
    
    return result;
  }

  isRateLimited(provider, limit) {
    const now = Date.now();
    const windowStart = now - limit.window;
    
    // Clean old records
    this.cleanupOldRecords(windowStart);
    
    // Count recent emails
    const recentEmails = Array.from(this.sentEmails.keys())
      .filter(key => key.startsWith(provider) && 
                   parseInt(key.split('_')[1]) > windowStart);
    
    return recentEmails.length >= limit.emails;
  }

  recordSentEmail(provider) {
    const key = `${provider}_${Date.now()}`;
    this.sentEmails.set(key, true);
  }

  cleanupOldRecords(cutoffTime) {
    for (const key of this.sentEmails.keys()) {
      const timestamp = parseInt(key.split('_')[1]);
      if (timestamp < cutoffTime) {
        this.sentEmails.delete(key);
      }
    }
  }

  calculateWaitTime(provider, limit) {
    const now = Date.now();
    const windowStart = now - limit.window;
    
    // Find oldest email in current window
    let oldestTime = now;
    for (const key of this.sentEmails.keys()) {
      if (key.startsWith(provider)) {
        const timestamp = parseInt(key.split('_')[1]);
        if (timestamp > windowStart && timestamp < oldestTime) {
          oldestTime = timestamp;
        }
      }
    }
    
    return (oldestTime + limit.window) - now;
  }
}
```

**Rate limiting strategies:**
- Provider-specific limits
- Sliding window approach
- Queue-based throttling
- Redis-based distributed rate limiting

### Q10. How would you integrate Nodemailer with a message queue?

**Answer:**
Use Bull queue with Redis for scalable email processing:

```js
const Queue = require('bull');

class QueueEmailService {
  constructor() {
    this.emailQueue = new Queue('email processing', {
      redis: { host: 'localhost', port: 6379 }
    });
    
    this.transporter = nodemailer.createTransport(/* config */);
    this.setupProcessors();
  }

  setupProcessors() {
    // Process regular emails
    this.emailQueue.process('send-email', 5, async (job) => {
      return await this.processEmail(job);
    });

    // Process bulk emails
    this.emailQueue.process('send-bulk', 2, async (job) => {
      return await this.processBulkEmail(job);
    });

    // Handle failures
    this.emailQueue.on('failed', (job, err) => {
      console.error(`Job ${job.id} failed:`, err);
    });
  }

  async queueEmail(mailOptions, options = {}) {
    const job = await this.emailQueue.add('send-email', mailOptions, {
      attempts: 3,
      backoff: 'exponential',
      delay: options.delay || 0,
      priority: options.priority || 'normal'
    });

    return { jobId: job.id, queued: true };
  }

  async processEmail(job) {
    const { data } = job;
    
    try {
      const result = await this.transporter.sendMail(data);
      return {
        success: true,
        messageId: result.messageId,
        recipient: data.to
      };
    } catch (error) {
      throw new Error(`Email sending failed: ${error.message}`);
    }
  }

  async processBulkEmail(job) {
    const { emails } = job.data;
    const results = [];
    
    for (const emailOptions of emails) {
      try {
        const result = await this.transporter.sendMail(emailOptions);
        results.push({ success: true, recipient: emailOptions.to, messageId: result.messageId });
        
        // Rate limiting between emails
        await new Promise(resolve => setTimeout(resolve, 1000));
      } catch (error) {
        results.push({ success: false, recipient: emailOptions.to, error: error.message });
      }
    }
    
    return results;
  }
}

// Usage
const queueService = new QueueEmailService();

// Queue single email
await queueService.queueEmail({
  to: 'user@example.com',
  subject: 'Queued Email',
  html: '<h1>This will be processed by queue</h1>'
});

// Queue bulk emails
await queueService.queueEmail({
  emails: [
    { to: 'user1@example.com', subject: 'Bulk 1', html: '<p>Content 1</p>' },
    { to: 'user2@example.com', subject: 'Bulk 2', html: '<p>Content 2</p>' }
  ]
}, { type: 'bulk' });
```

**Benefits of queue-based approach:**
- Non-blocking API responses
- Automatic retry mechanisms
- Better scalability
- Load distribution
- Failure isolation

---

## 3. Senior Level Questions (4-5+ years experience)

### Q11. Design a scalable email service architecture for a SaaS platform

**Answer:**
A scalable email service should handle high volume, provide reliability, and support different email types.

**Architecture Components:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Web Client    â”‚    â”‚   Mobile App    â”‚    â”‚  Internal Tool  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      API Gateway          â”‚
                    â”‚   (Express/Fastify)       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                      â”‚                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   User Service    â”‚  â”‚   Order Service   â”‚  â”‚  Notification     â”‚
â”‚   (Auth, Profile) â”‚  â”‚   (Processing)    â”‚  â”‚  Service          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚     Email Service         â”‚
                    â”‚   (Nodemailer + Queue)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                      â”‚                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Redis Queue   â”‚  â”‚   Load Balancer  â”‚  â”‚  Monitoring       â”‚
â”‚   (Bull Queue)    â”‚  â”‚  (Provider Failover) â”‚ â”‚  (Metrics/Logs)   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                      â”‚                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚     Gmail SMTP    â”‚  â”‚   AWS SES         â”‚  â”‚   SendGrid API    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Implementation:**

```js
class ScalableEmailService {
  constructor() {
    this.queues = {
      critical: new Queue('critical-emails'), // 2FA, password reset
      transactional: new Queue('transactional-emails'), // Welcome, orders
      marketing: new Queue('marketing-emails'), // Newsletters
      bulk: new Queue('bulk-emails') // Reports, notifications
    };
    
    this.providers = {
      primary: new SESProvider(),
      secondary: new SendGridProvider(),
      backup: new GmailProvider()
    };
    
    this.router = new EmailRouter(this.providers);
    this.metrics = new EmailMetrics();
  }

  async sendEmail(type, message, options = {}) {
    // Route to appropriate queue
    const queue = this.queues[type] || this.queues.transactional;
    
    // Add to queue with appropriate priority
    const job = await queue.add('send', {
      type,
      message,
      timestamp: Date.now()
    }, {
      priority: this.getPriority(type),
      attempts: this.getMaxAttempts(type),
      backoff: 'exponential'
    });
    
    return { jobId: job.id, queued: true };
  }

  async processEmail(job) {
    const { type, message } = job.data;
    const startTime = Date.now();
    
    try {
      // Select provider with failover
      const result = await this.router.sendWithFailover(message);
      
      // Record metrics
      this.metrics.recordSuccess(type, result.provider, Date.now() - startTime);
      
      return result;
      
    } catch (error) {
      // Record failure
      this.metrics.recordFailure(type, error, Date.now() - startTime);
      
      // Determine if should retry
      if (this.shouldRetry(error, job.attemptsMade)) {
        throw error; // Let queue handle retry
      }
      
      // Permanent failure - notify monitoring
      await this.alertingService.notifyPermanentFailure(job, error);
      throw error;
    }
  }

  getPriority(type) {
    const priorities = {
      critical: 10,
      transactional: 5,
      marketing: 1,
      bulk: 0
    };
    return priorities[type] || 5;
  }

  getMaxAttempts(type) {
    const attempts = {
      critical: 5,
      transactional: 3,
      marketing: 2,
      bulk: 1
    };
    return attempts[type] || 3;
  }
}

class EmailRouter {
  constructor(providers) {
    this.providers = providers;
    this.circuitBreakers = new Map();
  }

  async sendWithFailover(message) {
    const providerOrder = ['primary', 'secondary', 'backup'];
    
    for (const providerName of providerOrder) {
      const provider = this.providers[providerName];
      
      if (this.isProviderAvailable(providerName)) {
        try {
          const result = await provider.send(message);
          this.recordSuccess(providerName);
          return { ...result, provider: providerName };
        } catch (error) {
          this.recordFailure(providerName, error);
          console.warn(`Provider ${providerName} failed:`, error.message);
        }
      }
    }
    
    throw new Error('All email providers failed');
  }

  isProviderAvailable(providerName) {
    const circuitBreaker = this.circuitBreakers.get(providerName);
    return !circuitBreaker || !circuitBreaker.isOpen();
  }
}
```

**Key Features:**
- Multi-tier queue system for different email types
- Provider failover with circuit breakers
- Comprehensive metrics and monitoring
- Horizontal scaling support
- Rate limiting and throttling
- Template management system

### Q12. How would you implement email provider failover and circuit breakers?

**Answer:**
Implement intelligent provider routing with health monitoring:

```js
class CircuitBreaker {
  constructor(failureThreshold = 5, timeout = 60000) {
    this.failureThreshold = failureThreshold;
    this.timeout = timeout;
    this.failureCount = 0;
    this.lastFailureTime = null;
    this.state = 'CLOSED'; // CLOSED, OPEN, HALF_OPEN
  }

  isOpen() {
    if (this.state === 'OPEN') {
      if (Date.now() - this.lastFailureTime > this.timeout) {
        this.state = 'HALF_OPEN';
        return false;
      }
      return true;
    }
    return false;
  }

  recordSuccess() {
    this.failureCount = 0;
    this.state = 'CLOSED';
  }

  recordFailure() {
    this.failureCount++;
    this.lastFailureTime = Date.now();
    
    if (this.failureCount >= this.failureThreshold) {
      this.state = 'OPEN';
    }
  }
}

class EmailProviderFailover {
  constructor() {
    this.providers = {
      ses: new SESProvider(),
      sendgrid: new SendGridProvider(),
      gmail: new GmailProvider()
    };
    
    this.circuitBreakers = {
      ses: new CircuitBreaker(5, 60000),
      sendgrid: new CircuitBreaker(3, 120000),
      gmail: new CircuitBreaker(10, 30000)
    };
    
    this.providerStats = {
      ses: { sent: 0, failed: 0, avgResponseTime: 0 },
      sendgrid: { sent: 0, failed: 0, avgResponseTime: 0 },
      gmail: { sent: 0, failed: 0, avgResponseTime: 0 }
    };
    
    this.healthCheckInterval = 30000; // 30 seconds
    this.startHealthChecks();
  }

  async sendEmail(message, strategy = 'primary-first') {
    switch (strategy) {
      case 'primary-first':
        return await this.sendWithPrimaryFirst(message);
      case 'load-balanced':
        return await this.sendWithLoadBalancing(message);
      case 'round-robin':
        return await this.sendWithRoundRobin(message);
      default:
        return await this.sendWithPrimaryFirst(message);
    }
  }

  async sendWithPrimaryFirst(message) {
    const providers = ['ses', 'sendgrid', 'gmail'];
    
    for (const providerName of providers) {
      if (this.isProviderHealthy(providerName)) {
        try {
          const result = await this.sendWithProvider(providerName, message);
          this.recordSuccess(providerName);
          return { ...result, provider: providerName };
        } catch (error) {
          this.recordFailure(providerName, error);
          console.warn(`Provider ${providerName} failed:`, error.message);
        }
      }
    }
    
    throw new Error('All providers failed');
  }

  async sendWithLoadBalancing(message) {
    const healthyProviders = this.getHealthyProviders();
    if (healthyProviders.length === 0) {
      throw new Error('No healthy providers available');
    }
    
    // Select provider based on performance metrics
    const selectedProvider = this.selectProviderByPerformance(healthyProviders);
    
    try {
      const result = await this.sendWithProvider(selectedProvider, message);
      this.recordSuccess(selectedProvider);
      return { ...result, provider: selectedProvider };
    } catch (error) {
      this.recordFailure(selectedProvider, error);
      
      // Try other providers
      return await this.sendWithPrimaryFirst(message);
    }
  }

  selectProviderByPerformance(providers) {
    // Score providers based on success rate and response time
    const scores = {};
    
    for (const provider of providers) {
      const stats = this.providerStats[provider];
      const successRate = stats.sent / (stats.sent + stats.failed);
      const responseScore = Math.max(0, 1000 - stats.avgResponseTime) / 1000;
      
      scores[provider] = (successRate * 0.7) + (responseScore * 0.3);
    }
    
    return Object.keys(scores).reduce((best, current) => 
      scores[current] > scores[best] ? current : best
    );
  }

  isProviderHealthy(providerName) {
    const circuitBreaker = this.circuitBreakers[providerName];
    return !circuitBreaker.isOpen();
  }

  getHealthyProviders() {
    return Object.keys(this.providers).filter(provider => 
      this.isProviderHealthy(provider)
    );
  }

  async sendWithProvider(providerName, message) {
    const provider = this.providers[providerName];
    const startTime = Date.now();
    
    try {
      const result = await provider.send(message);
      const responseTime = Date.now() - startTime;
      
      // Update stats
      this.updateProviderStats(providerName, true, responseTime);
      
      return result;
    } catch (error) {
      const responseTime = Date.now() - startTime;
      
      // Update stats
      this.updateProviderStats(providerName, false, responseTime);
      
      throw error;
    }
  }

  updateProviderStats(providerName, success, responseTime) {
    const stats = this.providerStats[providerName];
    
    if (success) {
      stats.sent++;
    } else {
      stats.failed++;
    }
    
    // Update average response time
    const totalRequests = stats.sent + stats.failed;
    stats.avgResponseTime = ((stats.avgResponseTime * (totalRequests - 1)) + responseTime) / totalRequests;
  }

  recordSuccess(providerName) {
    this.circuitBreakers[providerName].recordSuccess();
  }

  recordFailure(providerName, error) {
    this.circuitBreakers[providerName].recordFailure();
    
    // Log failure for monitoring
    console.error(`Provider ${providerName} failure:`, {
      error: error.message,
      code: error.code,
      timestamp: new Date().toISOString()
    });
  }

  startHealthChecks() {
    setInterval(async () => {
      await this.performHealthChecks();
    }, this.healthCheckInterval);
  }

  async performHealthChecks() {
    for (const [providerName, provider] of Object.entries(this.providers)) {
      try {
        await provider.healthCheck();
        // Health check passed - circuit breaker stays closed
      } catch (error) {
        console.warn(`Health check failed for ${providerName}:`, error.message);
        // Don't change circuit breaker state for health check failures
        // Let actual sending failures handle that
      }
    }
  }

  getProviderStats() {
    return {
      providers: this.providerStats,
      circuitBreakers: Object.keys(this.circuitBreakers).map(name => ({
        name,
        state: this.circuitBreakers[name].state,
        failureCount: this.circuitBreakers[name].failureCount
      }))
    };
  }
}
```

**Key Features:**
- Circuit breakers prevent cascading failures
- Multiple failover strategies
- Performance-based provider selection
- Health monitoring
- Comprehensive metrics

### Q13. How would you implement email analytics and deliverability monitoring?

**Answer:**
Implement comprehensive analytics with tracking and monitoring:

```js
class EmailAnalyticsService {
  constructor() {
    this.trackingPixelService = new TrackingPixelService();
    this.webhookService = new WebhookService();
    this.metricsCollector = new MetricsCollector();
    this.deliverabilityMonitor = new DeliverabilityMonitor();
  }

  async sendEmailWithTracking(mailOptions) {
    // Add tracking to email
    const trackedEmail = await this.addTracking(mailOptions);
    
    // Send email
    const result = await this.transporter.sendMail(trackedEmail);
    
    // Record send event
    await this.recordEvent('sent', {
      messageId: result.messageId,
      recipient: mailOptions.to,
      timestamp: new Date(),
      provider: this.providerName
    });
    
    return {
      ...result,
      trackingId: trackedEmail.trackingId
    };
  }

  async addTracking(mailOptions) {
    const trackingId = this.generateTrackingId();
    
    // Add tracking pixel for open tracking
    const trackingPixel = this.trackingPixelService.generatePixel(trackingId);
    
    // Add click tracking to links
    const trackedHtml = this.addClickTracking(mailOptions.html || '', trackingId);
    
    return {
      ...mailOptions,
      html: trackedHtml + trackingPixel,
      trackingId: trackingId,
      headers: {
        ...mailOptions.headers,
        'X-Tracking-ID': trackingId
      }
    };
  }

  addClickTracking(html, trackingId) {
    // Replace all links with tracked links
    return html.replace(
      /<a\s+([^>]*?)href=["']([^"']+)["']([^>]*?)>/gi,
      (match, beforeAttrs, url, afterAttrs) => {
        const trackedUrl = `${process.env.BASE_URL}/track/click?tid=${trackingId}&url=${encodeURIComponent(url)}`;
        return `<a ${beforeAttrs}href="${trackedUrl}"${afterAttrs}>`;
      }
    );
  }

  async handleOpenEvent(trackingId, userAgent, ip) {
    await this.recordEvent('opened', {
      trackingId,
      userAgent,
      ip,
      timestamp: new Date()
    });
    
    // Update metrics
    this.metricsCollector.increment('emails.opened');
  }

  async handleClickEvent(trackingId, targetUrl, userAgent, ip) {
    await this.recordEvent('clicked', {
      trackingId,
      targetUrl,
      userAgent,
      ip,
      timestamp: new Date()
    });
    
    // Update metrics
    this.metricsCollector.increment('emails.clicked');
    
    // Redirect to original URL
    return { redirectUrl: targetUrl };
  }

  async handleWebhookEvent(provider, event) {
    const eventData = {
      provider,
      event: event.event,
      messageId: event.message_id,
      recipient: event.email,
      timestamp: event.timestamp || new Date(),
      reason: event.reason,
      response: event.response
    };
    
    await this.recordEvent(event.event, eventData);
    
    // Update deliverability metrics
    this.deliverabilityMonitor.processEvent(eventData);
  }

  async recordEvent(eventType, data) {
    // Store in database for analytics
    await this.database.collection('email_events').insertOne({
      eventType,
      data,
      timestamp: new Date()
    });
    
    // Update real-time metrics
    this.updateRealTimeMetrics(eventType, data);
  }

  updateRealTimeMetrics(eventType, data) {
    const key = `email:${eventType}`;
    this.redis.incr(key);
    this.redis.expire(key, 86400); // 24 hours
    
    // Provider-specific metrics
    if (data.provider) {
      const providerKey = `email:${eventType}:${data.provider}`;
      this.redis.incr(providerKey);
      this.redis.expire(providerKey, 86400);
    }
  }

  async getAnalytics(dateRange, filters = {}) {
    const pipeline = [
      {
        $match: {
          timestamp: {
            $gte: dateRange.start,
            $lte: dateRange.end
          },
          ...filters
        }
      },
      {
        $group: {
          _id: '$eventType',
          count: { $sum: 1 },
          uniqueRecipients: { $addToSet: '$data.recipient' }
        }
      },
      {
        $addFields: {
          uniqueCount: { $size: '$uniqueRecipients' }
        }
      }
    ];
    
    const results = await this.database.collection('email_events')
      .aggregate(pipeline)
      .toArray();
    
    return this.formatAnalyticsResults(results);
  }

  formatAnalyticsResults(results) {
    const analytics = {
      total: 0,
      sent: 0,
      delivered: 0,
      opened: 0,
      clicked: 0,
      failed: 0,
      bounced: 0,
      complained: 0
    };
    
    results.forEach(result => {
      analytics[result._id] = result.count;
      analytics.total += result.count;
    });
    
    // Calculate rates
    if (analytics.sent > 0) {
      analytics.deliveryRate = (analytics.delivered / analytics.sent) * 100;
      analytics.openRate = (analytics.opened / analytics.delivered) * 100;
      analytics.clickRate = (analytics.clicked / analytics.opened) * 100;
      analytics.bounceRate = (analytics.bounced / analytics.sent) * 100;
    }
    
    return analytics;
  }
}

class DeliverabilityMonitor {
  constructor() {
    this.problemThresholds = {
      bounceRate: 5, // 5%
      complaintRate: 0.1, // 0.1%
      failureRate: 10 // 10%
    };
  }

  processEvent(event) {
    switch (event.event) {
      case 'bounced':
        this.handleBounce(event);
        break;
      case 'complained':
        this.handleComplaint(event);
        break;
      case 'failed':
        this.handleFailure(event);
        break;
    }
  }

  async handleBounce(event) {
    // Categorize bounce type
    const bounceType = this.categorizeBounce(event);
    
    // Update recipient status
    await this.updateRecipientStatus(event.recipient, 'bounced', bounceType);
    
    // Check for deliverability issues
    const bounceRate = await this.calculateBounceRate();
    if (bounceRate > this.problemThresholds.bounceRate) {
      await this.alertDeliverabilityIssue('high_bounce_rate', { bounceRate });
    }
  }

  async handleComplaint(event) {
    // Update recipient status
    await this.updateRecipientStatus(event.recipient, 'complained');
    
    // Remove from mailing lists
    await this.removeFromMailingLists(event.recipient);
    
    // Check complaint rate
    const complaintRate = await this.calculateComplaintRate();
    if (complaintRate > this.problemThresholds.complaintRate) {
      await this.alertDeliverabilityIssue('high_complaint_rate', { complaintRate });
    }
  }

  async calculateBounceRate() {
    const last24h = new Date(Date.now() - 24 * 60 * 60 * 1000);
    
    const pipeline = [
      {
        $match: {
          timestamp: { $gte: last24h },
          $or: [
            { eventType: 'sent' },
            { eventType: 'bounced' }
          ]
        }
      },
      {
        $group: {
          _id: '$eventType',
          count: { $sum: 1 }
        }
      }
    ];
    
    const results = await this.database.collection('email_events')
      .aggregate(pipeline)
      .toArray();
    
    const sent = results.find(r => r._id === 'sent')?.count || 0;
    const bounced = results.find(r => r._id === 'bounced')?.count || 0;
    
    return sent > 0 ? (bounced / sent) * 100 : 0;
  }

  categorizeBounce(event) {
    const message = event.reason?.toLowerCase() || '';
    
    if (message.includes('permanent') || message.includes('hard')) {
      return 'hard';
    } else if (message.includes('temporary') || message.includes('soft')) {
      return 'soft';
    } else if (message.includes('spam') || message.includes('blocked')) {
      return 'spam';
    }
    
    return 'unknown';
  }

  async alertDeliverabilityIssue(issueType, data) {
    const alert = {
      type: issueType,
      severity: 'high',
      data,
      timestamp: new Date(),
      requiresAction: true
    };
    
    // Send alert to monitoring system
    await this.alertingService.sendAlert(alert);
    
    // Notify email administrators
    await this.notificationService.notifyAdmins(alert);
  }
}
```

**Key Features:**
- Open and click tracking
- Webhook integration for provider events
- Real-time metrics collection
- Deliverability monitoring
- Automated alerting for issues
- Comprehensive analytics dashboard

### Q14. How would you design a multi-tenant email system?

**Answer:**
Design a system that supports multiple organizations with isolation and customization:

```js
class MultiTenantEmailService {
  constructor() {
    this.tenantConfigs = new Map();
    this.providerPools = new Map();
    this.templateManager = new MultiTenantTemplateManager();
    this.rateLimiter = new MultiTenantRateLimiter();
  }

  async initializeTenant(tenantId, config) {
    // Validate tenant configuration
    this.validateTenantConfig(config);
    
    // Create tenant-specific transporter pool
    const pool = this.createTransporterPool(config.providers);
    this.providerPools.set(tenantId, pool);
    
    // Store tenant configuration
    this.tenantConfigs.set(tenantId, {
      ...config,
      settings: {
        defaultFrom: config.defaultFrom,
        replyTo: config.replyTo,
        trackingEnabled: config.trackingEnabled ?? true,
        customHeaders: config.customHeaders || {},
        rateLimits: config.rateLimits || this.getDefaultRateLimits()
      }
    });
    
    // Load tenant templates
    await this.templateManager.loadTenantTemplates(tenantId, config.templatePath);
    
    console.log(`Tenant ${tenantId} initialized successfully`);
  }

  createTransporterPool(providers) {
    const pool = {
      primary: null,
      fallback: [],
      circuitBreakers: new Map()
    };
    
    // Create primary provider
    if (providers.primary) {
      pool.primary = nodemailer.createTransport(providers.primary);
      pool.circuitBreakers.set('primary', new CircuitBreaker());
    }
    
    // Create fallback providers
    providers.fallback?.forEach((config, index) => {
      pool.fallback[index] = nodemailer.createTransport(config);
      pool.circuitBreakers.set(`fallback_${index}`, new CircuitBreaker());
    });
    
    return pool;
  }

  async sendEmail(tenantId, mailOptions, options = {}) {
    // Validate tenant
    if (!this.tenantConfigs.has(tenantId)) {
      throw new Error(`Tenant ${tenantId} not initialized`);
    }
    
    const tenantConfig = this.tenantConfigs.get(tenantId);
    
    // Check rate limits
    await this.rateLimiter.checkLimit(tenantId, mailOptions.to);
    
    // Apply tenant-specific settings
    const enhancedMailOptions = this.applyTenantSettings(mailOptions, tenantConfig);
    
    // Add tenant tracking
    const trackedMailOptions = await this.addTenantTracking(
      enhancedMailOptions, 
      tenantId, 
      options
    );
    
    // Send with provider failover
    const result = await this.sendWithFailover(tenantId, trackedMailOptions);
    
    // Record tenant metrics
    await this.recordTenantMetrics(tenantId, result);
    
    return {
      ...result,
      tenantId,
      trackingEnabled: tenantConfig.settings.trackingEnabled
    };
  }

  applyTenantSettings(mailOptions, tenantConfig) {
    const settings = tenantConfig.settings;
    
    return {
      ...mailOptions,
      // Use tenant default from if not specified
      from: mailOptions.from || settings.defaultFrom,
      
      // Add reply-to if configured
      replyTo: mailOptions.replyTo || settings.replyTo,
      
      // Add custom headers
      headers: {
        'X-Tenant-ID': tenantConfig.tenantId,
        ...settings.customHeaders,
        ...mailOptions.headers
      },
      
      // Apply tenant branding if template is used
      ...(mailOptions.template && {
        templateData: {
          ...mailOptions.templateData,
          tenant: {
            name: tenantConfig.name,
            logo: tenantConfig.logoUrl,
            colors: tenantConfig.brandColors
          }
        }
      })
    };
  }

  async addTenantTracking(mailOptions, tenantId, options) {
    const tenantConfig = this.tenantConfigs.get(tenantId);
    
    if (!tenantConfig.settings.trackingEnabled) {
      return mailOptions;
    }
    
    const trackingId = this.generateTenantTrackingId(tenantId);
    
    // Add tracking pixel
    const trackingPixel = this.generateTrackingPixel(trackingId, tenantId);
    
    // Add click tracking
    const trackedHtml = this.addClickTracking(mailOptions.html || '', trackingId, tenantId);
    
    return {
      ...mailOptions,
      html: trackedHtml + trackingPixel,
      trackingId,
      headers: {
        ...mailOptions.headers,
        'X-Tracking-ID': trackingId,
        'X-Tenant-Tracking': 'enabled'
      }
    };
  }

  async sendWithFailover(tenantId, mailOptions) {
    const pool = this.providerPools.get(tenantId);
    
    // Try primary provider first
    if (pool.primary && !pool.circuitBreakers.get('primary').isOpen()) {
      try {
        const result = await pool.primary.sendMail(mailOptions);
        pool.circuitBreakers.get('primary').recordSuccess();
        return { ...result, provider: 'primary' };
      } catch (error) {
        pool.circuitBreakers.get('primary').recordFailure();
        console.warn(`Primary provider failed for tenant ${tenantId}:`, error.message);
      }
    }
    
    // Try fallback providers
    for (let i = 0; i < pool.fallback.length; i++) {
      const fallbackKey = `fallback_${i}`;
      const circuitBreaker = pool.circuitBreakers.get(fallbackKey);
      
      if (!circuitBreaker.isOpen()) {
        try {
          const result = await pool.fallback[i].sendMail(mailOptions);
          circuitBreaker.recordSuccess();
          return { ...result, provider: fallbackKey };
        } catch (error) {
          circuitBreaker.recordFailure();
          console.warn(`Fallback provider ${i} failed for tenant ${tenantId}:`, error.message);
        }
      }
    }
    
    throw new Error(`All providers failed for tenant ${tenantId}`);
  }

  async sendBulkEmail(tenantId, emailList, options = {}) {
    const tenantConfig = this.tenantConfigs.get(tenantId);
    
    // Validate bulk email limits
    if (emailList.length > tenantConfig.settings.rateLimits.bulkLimit) {
      throw new Error(`Bulk email limit exceeded for tenant ${tenantId}`);
    }
    
    // Process in batches to respect rate limits
    const batchSize = tenantConfig.settings.rateLimits.batchSize || 100;
    const batches = this.chunkArray(emailList, batchSize);
    
    const results = [];
    
    for (let i = 0; i < batches.length; i++) {
      const batch = batches[i];
      
      // Process batch
      const batchResults = await Promise.allSettled(
        batch.map(email => this.sendEmail(tenantId, email, options))
      );
      
      results.push(...batchResults.map((result, index) => ({
        index: i * batchSize + index,
        success: result.status === 'fulfilled',
        result: result.status === 'fulfilled' ? result.value : null,
        error: result.status === 'rejected' ? result.reason : null
      })));
      
      // Rate limiting between batches
      if (i < batches.length - 1) {
        await this.sleep(tenantConfig.settings.rateLimits.batchDelay || 1000);
      }
    }
    
    return this.summarizeBulkResults(results, emailList);
  }

  async getTenantAnalytics(tenantId, dateRange) {
    const pipeline = [
      {
        $match: {
          'data.tenantId': tenantId,
          timestamp: {
            $gte: dateRange.start,
            $lte: dateRange.end
          }
        }
      },
      {
        $group: {
          _id: '$eventType',
          count: { $sum: 1 }
        }
      }
    ];
    
    const results = await this.database.collection('email_events')
      .aggregate(pipeline)
      .toArray();
    
    return this.formatTenantAnalytics(results);
  }

  async updateTenantSettings(tenantId, settings) {
    const tenantConfig = this.tenantConfigs.get(tenantId);
    if (!tenantConfig) {
      throw new Error(`Tenant ${tenantId} not found`);
    }
    
    // Update settings
    tenantConfig.settings = { ...tenantConfig.settings, ...settings };
    
    // Update rate limits if changed
    if (settings.rateLimits) {
      await this.rateLimiter.updateTenantLimits(tenantId, settings.rateLimits);
    }
    
    // Reload templates if template path changed
    if (settings.templatePath) {
      await this.templateManager.loadTenantTemplates(tenantId, settings.templatePath);
    }
    
    console.log(`Settings updated for tenant ${tenantId}`);
  }

  generateTenantTrackingId(tenantId) {
    return `${tenantId}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  chunkArray(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }

  sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

class MultiTenantRateLimiter {
  constructor() {
    this.tenantLimits = new Map();
    this.usage = new Map();
  }

  async checkLimit(tenantId, recipient) {
    const limits = this.tenantLimits.get(tenantId);
    if (!limits) return;
    
    const now = Date.now();
    const windowStart = now - 60000; // 1 minute window
    
    // Clean old usage records
    this.cleanupUsage(windowStart);
    
    // Check per-minute limit
    const minuteKey = `${tenantId}_minute_${Math.floor(now / 60000)}`;
    const minuteUsage = this.usage.get(minuteKey) || 0;
    
    if (minuteUsage >= limits.perMinute) {
      throw new Error(`Rate limit exceeded for tenant ${tenantId}`);
    }
    
    // Check hourly limit
    const hourKey = `${tenantId}_hour_${Math.floor(now / 3600000)}`;
    const hourUsage = this.usage.get(hourKey) || 0;
    
    if (hourUsage >= limits.perHour) {
      throw new Error(`Hourly rate limit exceeded for tenant ${tenantId}`);
    }
    
    // Record usage
    this.usage.set(minuteKey, minuteUsage + 1);
    this.usage.set(hourKey, hourUsage + 1);
  }

  cleanupWindow(cutoffTime) {
    for (const [key, timestamp] of this.usage) {
      if (timestamp < cutoffTime) {
        this.usage.delete(key);
      }
    }
  }
}
```

**Key Features:**
- Tenant isolation with separate configurations
- Provider pools per tenant
- Custom rate limiting per tenant
- Template management per tenant
- Analytics and metrics per tenant
- Failover handling per tenant

### Q15. How would you handle email localization and internationalization?

**Answer:**
Implement a comprehensive localization system:

```js
class EmailLocalizationService {
  constructor() {
    this.supportedLocales = ['en', 'es', 'fr', 'de', 'it', 'pt', 'ja', 'zh', 'ar', 'hi'];
    this.templateCache = new Map();
    this.translations = new Map();
    this.formatters = new Map();
  }

  async initialize() {
    // Load translations for all supported locales
    for (const locale of this.supportedLocales) {
      await this.loadTranslations(locale);
      this.setupFormatters(locale);
    }
  }

  async loadTranslations(locale) {
    const translationPath = `./locales/${locale}/email.json`;
    try {
      const translations = await fs.readFile(translationPath, 'utf8');
      this.translations.set(locale, JSON.parse(translations));
    } catch (error) {
      console.warn(`Failed to load translations for ${locale}:`, error.message);
      // Fallback to empty translations
      this.translations.set(locale, {});
    }
  }

  setupFormatters(locale) {
    this.formatters.set(locale, {
      date: new Intl.DateTimeFormat(locale, {
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      }),
      currency: new Intl.NumberFormat(locale, {
        style: 'currency',
        currency: this.getCurrencyForLocale(locale)
      }),
      number: new Intl.NumberFormat(locale)
    });
  }

  getCurrencyForLocale(locale) {
    const currencyMap = {
      'en': 'USD',
      'es': 'EUR',
      'fr': 'EUR',
      'de': 'EUR',
      'it': 'EUR',
      'pt': 'BRL',
      'ja': 'JPY',
      'zh': 'CNY',
      'ar': 'SAR',
      'hi': 'INR'
    };
    
    return currencyMap[locale] || 'USD';
  }

  async sendLocalizedEmail(templateName, recipient, data, userLocale = null) {
    // Detect locale
    const locale = await this.detectLocale(recipient, userLocale);
    
    // Get localized template
    const localizedTemplate = await this.getLocalizedTemplate(templateName, locale);
    
    // Localize data
    const localizedData = await this.localizeData(data, locale);
    
    // Render template
    const { html, text } = await this.renderTemplate(localizedTemplate, localizedData);
    
    // Apply RTL styling if needed
    const processedHtml = this.applyRTLStyling(html, locale);
    
    // Send email
    const mailOptions = {
      to: recipient,
      subject: this.t('email.subject', locale, localizedData),
      html: processedHtml,
      text: text,
      headers: {
        'Content-Language': locale,
        'X-Email-Locale': locale
      }
    };
    
    return await this.transporter.sendMail(mailOptions);
  }

  async detectLocale(recipient, userLocale = null) {
    // Priority: user preference > browser > email domain > default
    
    if (userLocale && this.isLocaleSupported(userLocale)) {
      return userLocale;
    }
    
    // Try to detect from email domain
    const domain = recipient.split('@')[1];
    const domainLocale = this.getLocaleFromDomain(domain);
    if (domainLocale && this.isLocaleSupported(domainLocale)) {
      return domainLocale;
    }
    
    // Default to English
    return 'en';
  }

  getLocaleFromDomain(domain) {
    const domainMap = {
      'gmail.com': 'en',
      'yahoo.com': 'en',
      'hotmail.com': 'en',
      'gmail.co.uk': 'en',
      'gmail.es': 'es',
      'gmail.fr': 'fr',
      'gmail.de': 'de',
      'gmail.it': 'it',
      'gmail.co.jp': 'ja',
      'gmail.cn': 'zh'
    };
    
    return domainMap[domain.toLowerCase()];
  }

  isLocaleSupported(locale) {
    return this.supportedLocales.includes(locale);
  }

  async getLocalizedTemplate(templateName, locale) {
    const cacheKey = `${templateName}_${locale}`;
    
    if (this.templateCache.has(cacheKey)) {
      return this.templateCache.get(cacheKey);
    }
    
    // Try to load locale-specific template
    let templatePath = `./templates/${locale}/${templateName}.hbs`;
    
    try {
      const templateContent = await fs.readFile(templatePath, 'utf8');
      const template = Handlebars.compile(templateContent);
      
      // Register locale-specific helpers
      this.registerLocaleHelpers(locale);
      
      this.templateCache.set(cacheKey, template);
      return template;
    } catch (error) {
      // Fallback to English template
      if (locale !== 'en') {
        console.warn(`Template not found for ${locale}, falling back to English`);
        return await this.getLocalizedTemplate(templateName, 'en');
      }
      
      throw error;
    }
  }

  registerLocaleHelpers(locale) {
    const formatters = this.formatters.get(locale);
    const translations = this.translations.get(locale);
    
    // Date formatting helper
    Handlebars.registerHelper('formatDate', (date, format) => {
      if (!date) return '';
      
      const dateObj = new Date(date);
      if (format === 'short') {
        return dateObj.toLocaleDateString(locale);
      }
      
      return formatters.date.format(dateObj);
    });
    
    // Currency formatting helper
    Handlebars.registerHelper('formatCurrency', (amount, currency) => {
      if (!amount) return '';
      
      if (currency) {
        const currencyFormatter = new Intl.NumberFormat(locale, {
          style: 'currency',
          currency: currency
        });
        return currencyFormatter.format(amount);
      }
      
      return formatters.currency.format(amount);
    });
    
    // Number formatting helper
    Handlebars.registerHelper('formatNumber', (number) => {
      if (!number) return '';
      return formatters.number.format(number);
    });
    
    // Translation helper
    Handlebars.registerHelper('t', (key, ...args) => {
      const options = args[args.length - 1];
      const params = args.slice(0, -1);
      
      return this.t(key, locale, options.hash || {}, ...params);
    });
    
    // Pluralization helper
    Handlebars.registerHelper('pluralize', (count, singular, plural) => {
      const pluralizationRules = this.getPluralizationRules(locale);
      const rule = pluralizationRules(count);
      
      if (rule === 'one') return singular;
      if (rule === 'few' && plural) return plural;
      return plural || singular + 's';
    });
  }

  getPluralizationRules(locale) {
    const rules = {
      'en': (n) => n === 1 ? 'one' : 'other',
      'es': (n) => n === 1 ? 'one' : 'other',
      'fr': (n) => n === 1 ? 'one' : 'other',
      'de': (n) => n === 1 ? 'one' : 'other',
      'ar': (n) => {
        if (n === 0) return 'zero';
        if (n === 1) return 'one';
        if (n === 2) return 'two';
        if (n % 100 >= 3 && n % 100 <= 10) return 'few';
        if (n % 100 >= 11 && n % 100 <= 99) return 'many';
        return 'other';
      },
      'zh': () => 'other', // Chinese doesn't have plurals
      'ja': () => 'other'  // Japanese doesn't have plurals
    };
    
    return rules[locale] || rules['en'];
  }

  async localizeData(data, locale) {
    const localizedData = { ...data };
    
    // Localize dates
    if (localizedData.date) {
      localizedData.formattedDate = this.formatters.get(locale).date.format(new Date(localizedData.date));
    }
    
    // Localize currency
    if (localizedData.amount) {
      localizedData.formattedAmount = this.formatters.get(locale).currency.format(localizedData.amount);
    }
    
    // Localize numbers
    if (localizedData.quantity) {
      localizedData.formattedQuantity = this.formatters.get(locale).number.format(localizedData.quantity);
    }
    
    // Add locale-specific data
    localizedData.locale = locale;
    localizedData.isRTL = this.isRTLLanguage(locale);
    localizedData.dateFormat = this.getDateFormat(locale);
    
    return localizedData;
  }

  isRTLLanguage(locale) {
    const rtlLanguages = ['ar', 'he', 'fa', 'ur'];
    return rtlLanguages.includes(locale);
  }

  getDateFormat(locale) {
    const dateFormats = {
      'en': 'MM/DD/YYYY',
      'es': 'DD/MM/YYYY',
      'fr': 'DD/MM/YYYY',
      'de': 'DD.MM.YYYY',
      'ja': 'YYYY/MM/DD',
      'zh': 'YYYY/MM/DD',
      'ar': 'DD/MM/YYYY'
    };
    
    return dateFormats[locale] || 'MM/DD/YYYY';
  }

  applyRTLStyling(html, locale) {
    if (!this.isRTLLanguage(locale)) {
      return html;
    }
    
    // Add RTL styling
    return html.replace('<html', '<html dir="rtl"')
              .replace('<body', '<body style="direction: rtl; text-align: right;"')
              .replace(/text-align:\s*left/g, 'text-align: right')
              .replace(/text-align:\s*right/g, 'text-align: left')
              .replace(/float:\s*left/g, 'float: right')
              .replace(/float:\s*right/g, 'float: left');
  }

  t(key, locale, params = {}, ...args) {
    const translations = this.translations.get(locale);
    if (!translations) return key;
    
    // Navigate nested keys
    const value = key.split('.').reduce((obj, k) => obj?.[k], translations);
    if (!value) return key;
    
    // Handle string interpolation
    if (typeof value === 'string' && args.length > 0) {
      return value.replace(/\{(\d+)\}/g, (match, index) => args[index] || match);
    }
    
    // Handle parameter substitution
    if (typeof value === 'string' && Object.keys(params).length > 0) {
      return value.replace(/\{\{(\w+)\}\}/g, (match, key) => params[key] || match);
    }
    
    return value;
  }

  async renderTemplate(template, data) {
    const html = template(data);
    
    // Generate text version
    const text = this.htmlToText(html);
    
    return { html, text };
  }

  htmlToText(html) {
    return html
      .replace(/<[^>]*>/g, '')
      .replace(/\s+/g, ' ')
      .trim();
  }
}

// Usage example
const localizationService = new EmailLocalizationService();
await localizationService.initialize();

// Send localized email
await localizationService.sendLocalizedEmail(
  'welcome',
  'user@example.com',
  {
    userName: 'John',
    planName: 'Premium',
    amount: 29.99,
    currency: 'USD',
    startDate: new Date()
  },
  'es' // Spanish
);
```

**Key Features:**
- Multi-language template support
- Automatic locale detection
- RTL language support
- Currency and number formatting
- Pluralization rules
- Fallback mechanisms

---

## System Design Questions

### Q16. Design an email service that can handle 1 million emails per day

**Requirements:**
- 1M emails/day (~12 emails/second average, peaks at 100/second)
- 99.9% uptime
- Multi-region support
- Real-time analytics
- Low latency for critical emails

**Architecture:**

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Load Balancer â”‚    â”‚   Load Balancer â”‚    â”‚   Load Balancer â”‚
â”‚   (US-East)     â”‚    â”‚   (EU-West)     â”‚    â”‚   (APAC)        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      API Gateway          â”‚
                    â”‚   (Rate Limiting, Auth)    â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                      â”‚                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Email Service  â”‚  â”‚   Email Service  â”‚  â”‚   Email Service  â”‚
â”‚   (US-East)      â”‚  â”‚   (EU-West)      â”‚  â”‚   (APAC)         â”‚
â”‚   - 10 Instances  â”‚  â”‚   - 5 Instances   â”‚  â”‚   - 3 Instances  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚                      â”‚                      â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚      Redis Cluster        â”‚
                    â”‚   (Queues + Cache)        â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                      â”‚                      â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PostgreSQL     â”‚  â”‚   Elasticsearch  â”‚  â”‚   S3 Bucket      â”‚
â”‚   (Metadata)     â”‚  â”‚   (Analytics)    â”‚  â”‚   (Attachments)  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                 â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚    Email Providers        â”‚
                    â”‚  (SES, SendGrid, Mailgun) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Key Components:**

1. **API Layer**: Rate limiting, authentication, request validation
2. **Service Layer**: Business logic, template rendering, provider selection
3. **Queue System**: Redis Cluster for high-throughput queuing
4. **Database**: PostgreSQL for transactional data, Elasticsearch for analytics
5. **Storage**: S3 for attachments and templates
6. **Monitoring**: Real-time metrics, alerting, health checks

**Scaling Strategy:**
- Horizontal scaling of service instances
- Database sharding by tenant/date
- Queue partitioning by priority/region
- CDN for static assets and attachments
- Multi-region deployment for latency

**Implementation:**

```js
class HighVolumeEmailService {
  constructor() {
    this.redisCluster = new Redis.Cluster([
      { host: 'redis-1', port: 6379 },
      { host: 'redis-2', port: 6379 },
      { host: 'redis-3', port: 6379 }
    ]);
    
    this.queues = {
      critical: new Bull('critical', { redis: this.redisCluster }),
      transactional: new Bull('transactional', { redis: this.redisCluster }),
      marketing: new Bull('marketing', { redis: this.redisCluster }),
      bulk: new Bull('bulk', { redis: this.redisCluster })
    };
    
    this.providers = this.setupProviderPool();
    this.metrics = new PrometheusMetrics();
    this.tracer = new JaegerTracer();
  }

  async sendEmail(request) {
    const span = this.tracer.startSpan('send_email');
    
    try {
      // Validate request
      this.validateRequest(request);
      
      // Select queue based on priority
      const queue = this.selectQueue(request.priority);
      
      // Add to queue with metadata
      const job = await queue.add('send', {
        ...request,
        metadata: {
          requestId: this.generateRequestId(),
          timestamp: Date.now(),
          region: this.getCurrentRegion(),
          version: '1.0'
        }
      }, {
        priority: this.getPriority(request.priority),
        delay: request.scheduleTime ? request.scheduleTime - Date.now() : 0,
        removeOnComplete: 1000,
        removeOnFail: 500
      });
      
      // Record metrics
      this.metrics.increment('emails.queued', {
        priority: request.priority,
        region: this.getCurrentRegion()
      });
      
      return {
        requestId: request.metadata.requestId,
        jobId: job.id,
        queued: true,
        estimatedDelivery: this.estimateDeliveryTime(request.priority)
      };
      
    } catch (error) {
      span.setTag('error', true);
      span.log({ error: error.message });
      throw error;
    } finally {
      span.finish();
    }
  }

  async processEmail(job) {
    const span = this.tracer.startSpan('process_email', {
      childOf: job.data.metadata.requestId
    });
    
    try {
      const { request, metadata } = job.data;
      
      // Select optimal provider
      const provider = await this.selectProvider(request, metadata);
      
      // Render template
      const renderedEmail = await this.renderTemplate(request.template, request.data);
      
      // Add tracking
      const trackedEmail = await this.addTracking(renderedEmail, metadata);
      
      // Send email
      const result = await provider.send(trackedEmail);
      
      // Record success
      await this.recordSuccess(metadata, result);
      
      // Update metrics
      this.metrics.increment('emails.sent', {
        provider: provider.name,
        priority: request.priority
      });
      
      return result;
      
    } catch (error) {
      // Record failure
      await this.recordFailure(job.data.metadata, error);
      
      // Update metrics
      this.metrics.increment('emails.failed', {
        error: error.code,
        priority: job.data.request.priority
      });
      
      throw error;
    } finally {
      span.finish();
    }
  }

  async selectProvider(request, metadata) {
    // Provider selection based on:
    // - Current load and health
    // - Geographic location
    // - Email type and volume
    // - Cost optimization
    
    const candidates = await this.getHealthyProviders();
    
    // Score providers
    const scored = candidates.map(provider => ({
      provider,
      score: this.scoreProvider(provider, request, metadata)
    }));
    
    // Select best provider
    scored.sort((a, b) => b.score - a.score);
    
    return scored[0].provider;
  }

  scoreProvider(provider, request, metadata) {
    let score = 0;
    
    // Health check (40% weight)
    score += provider.healthScore * 0.4;
    
    // Load balancing (30% weight)
    score += (1 - provider.currentLoad / provider.maxCapacity) * 0.3;
    
    // Geographic proximity (20% weight)
    score += this.calculateProximityScore(provider.region, metadata.region) * 0.2;
    
    // Cost optimization (10% weight)
    score += (1 - provider.costPerEmail / 0.001) * 0.1;
    
    return score;
  }

  async getHealthStatus() {
    const providers = await this.getProviderStatus();
    const queues = await this.getQueueStatus();
    const databases = await this.getDatabaseStatus();
    
    return {
      status: this.calculateOverallStatus(providers, queues, databases),
      providers,
      queues,
      databases,
      timestamp: new Date().toISOString()
    };
  }
}
```

**Monitoring and Alerting:**
- Prometheus metrics for performance
- Grafana dashboards for visualization
- Alertmanager for critical issues
- Log aggregation with ELK stack
- Distributed tracing with Jaeger

**Disaster Recovery:**
- Multi-region active-active setup
- Database replication and failover
- Queue persistence and recovery
- Provider failover mechanisms
- Automated failover testing

---

## Interview-Oriented Notes

**Question Categories to Master:**

1. **Beginner**: Basic concepts, simple implementations
2. **Mid-Level**: Error handling, templates, queues, OAuth2
3. **Senior**: Architecture, scalability, multi-tenancy, analytics
4. **System Design**: High-volume services, distributed systems

**Key Preparation Areas:**

- **Core Concepts**: SMTP vs API, transporters, authentication
- **Implementation**: Code examples, error handling, retry logic
- **Architecture**: Scalability, reliability, monitoring
- **Best Practices**: Security, performance, testing

**Common Mistakes to Avoid:**

- Not understanding the difference between SMTP and API services
- Ignoring error handling and retry mechanisms
- Not considering scalability and performance
- Overlooking security implications
- Missing monitoring and observability

**Tips for Success:**

- Start with basic concepts and build up complexity
- Provide concrete code examples
- Explain trade-offs between different approaches
- Consider real-world scenarios and constraints
- Demonstrate understanding of production concerns

[â† Code Examples](./09_code_examples.md) | [Next â†’ Real-World Case Study](./11_case_study.md)
